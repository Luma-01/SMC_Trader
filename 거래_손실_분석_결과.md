# 거래 손실 분석 결과 📊

## 1. 손실 거래 현황 분석

### 1.1 확인된 손실 거래
- **PENGUSDT**: -0.22 PNL (167 PENGU)
  - 진입: ~0.0330330
  - 청산: ~0.0343940  
  - 평균: 0.0334940
  - 손실률: 약 -0.66%

- **SOLUSDT**: -0.30 PNL (0.04 SOL)
  - 진입: 166.4300
  - 청산: 173.9400
  - 손실률: 약 -4.5%

- **SOLUSDT**: -0.01 PNL (0.04 SOL)  
  - 진입: 166.3400
  - 청산: 166.6300
  - 손실률: 약 -0.17%

## 2. 주요 문제점 분석

### 2.1 💥 스탑로스 관리 문제
```python
# 현재 코드의 문제점
min_rr = Decimal("0.01")            # 1% 최소 리스크
risk_ratio = (abs(entry_dec - sl_dec) / entry_dec).quantize(Decimal("0.00000001"))
if risk_ratio < min_rr:
    adj = (min_rr * entry_dec - abs(entry_dec - sl_dec)).quantize(tick_size)
    sl_dec = (sl_dec - adj) if direction == "long" else (sl_dec + adj)
```

**문제점**:
- 복잡한 SL 계산 로직으로 인한 혼란
- 동적 버퍼와 최소 SL 간격 보정이 중첩됨
- 실제 리스크가 의도한 것보다 클 수 있음

### 2.2 🎯 진입 타이밍 문제
```python
# FVG 제외 처리
if ob.get("pattern") == "fvg":
    continue
```

**문제점**:
- FVG를 완전히 제외하여 유효한 진입 기회 상실
- HTF와 LTF 조합에서 타이밍 불일치
- `zone_and_mss` 모드에서 과도하게 보수적인 진입

### 2.3 📈 TP/SL 비율 문제
```python
# 현재 TP 설정
htf_ob = detect_ob(htf)
if direction == "long":
    candidates = [Decimal(str(z["low"])) for z in htf_ob if z["type"] == "bearish" and Decimal(str(z["low"])) > entry_dec]
    if candidates:
        tp_dec = min(candidates)
```

**문제점**:
- 반대 OB를 TP로 설정하지만 거리가 너무 가까울 수 있음
- 시장 변동성을 고려하지 않은 고정적 TP
- RR 비율이 실제로는 1.5보다 낮을 수 있음

### 2.4 🔄 포지션 관리 문제
```python
# 스탑로스 알림 중복 발생
if now - last_alert > 30:  # 30초마다 최대 1번 알림
    send_discord_message(f"[STOP LOSS] {symbol} @ {mark_price:.2f}", "aggregated")
```

**문제점**:
- 거래소와 내부 캐시 동기화 지연
- 허위 스탑로스 알림 발생
- 포지션 상태 추적 불일치

## 3. 코드 개선 방안

### 3.1 🛠️ SL 계산 단순화
```python
# 개선된 SL 계산
def calculate_simple_sl(entry: float, direction: str, zone: dict, buffer_pct: float = 0.5):
    """
    단순하고 명확한 SL 계산
    """
    if zone:
        if direction == "long":
            sl = zone["low"] * (1 - buffer_pct / 100)
        else:
            sl = zone["high"] * (1 + buffer_pct / 100)
    else:
        # 2% 고정 SL
        sl = entry * (0.98 if direction == "long" else 1.02)
    
    return sl
```

### 3.2 📊 동적 TP 설정
```python
# 개선된 TP 계산
def calculate_dynamic_tp(entry: float, sl: float, direction: str, volatility: float):
    """
    변동성을 고려한 동적 TP 설정
    """
    base_rr = 1.5
    vol_multiplier = max(0.8, min(2.0, volatility / 0.02))  # 2% 기준
    
    risk = abs(entry - sl)
    reward = risk * base_rr * vol_multiplier
    
    tp = entry + reward if direction == "long" else entry - reward
    return tp
```

### 3.3 🎯 진입 조건 완화
```python
# 개선된 진입 조건
ENTRY_METHOD = "zone_or_mss"  # 더 적극적인 진입
# 또는 FVG 조건부 허용
if ob.get("pattern") == "fvg" and htf_confirmation:
    # HTF 확인 시에만 FVG 허용
    zone = ob
```

### 3.4 🔍 리스크 관리 강화
```python
# 포지션 크기 제한
max_risk_per_trade = 0.02  # 2% 최대 리스크
position_size = (total_balance * max_risk_per_trade) / abs(entry - sl)

# 일일 손실 제한
daily_loss_limit = 0.05  # 5% 일일 손실 제한
if daily_loss >= daily_loss_limit:
    return False  # 거래 중단
```

## 4. 전략 개선 권장사항

### 4.1 🎯 진입 전략 개선
- **백테스팅 수행**: 현재 전략의 승률과 평균 손익 분석
- **진입 조건 완화**: `zone_or_mss` 모드 테스트
- **FVG 조건부 허용**: HTF 확인 시 FVG 진입 허용

### 4.2 💰 리스크 관리 강화
- **최대 리스크 제한**: 거래당 2% 이하로 제한
- **상관관계 관리**: 유사한 코인 동시 거래 제한
- **일일 손실 제한**: 5% 도달 시 거래 중단

### 4.3 📈 성과 모니터링
- **실시간 PnL 추적**: 포지션별 실시간 손익 모니터링
- **승률 통계**: 심볼별, 시간대별 승률 분석
- **리스크 조정 수익률**: 샤프 비율 등 리스크 대비 수익률 측정

## 5. 즉시 적용 가능한 수정사항

### 5.1 설정 파일 수정
```python
# config/settings.py
ENTRY_METHOD = "zone_or_mss"  # 더 적극적인 진입
SL_BUFFER = 0.5  # 0.5% 고정 버퍼
RR = 2.0  # 2:1 리스크 리워드 비율
MAX_RISK_PER_TRADE = 0.02  # 2% 최대 리스크
```

### 5.2 포지션 크기 조정
```python
# 현재 10%에서 5%로 축소
qty = calculate_quantity(
    symbol,
    entry,
    get_total_balance() * 0.05,  # 5%로 축소
    leverage,
)
```

## 6. 결론

**주요 패배 원인**:
1. 복잡한 SL 계산으로 인한 예상보다 큰 손실
2. 과도하게 보수적인 진입 조건
3. 시장 변동성을 고려하지 않은 고정적 TP/SL
4. 포지션 크기 관리 부족

**개선 우선순위**:
1. **즉시**: 포지션 크기 5%로 축소
2. **단기**: SL 계산 로직 단순화
3. **중기**: 진입 조건 완화 및 백테스팅
4. **장기**: 동적 TP/SL 및 리스크 관리 고도화

이러한 개선을 통해 거래 성과를 향상시킬 수 있을 것으로 예상됩니다.